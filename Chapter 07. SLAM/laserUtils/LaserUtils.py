#!/usr/bin/env python

import numpy as np
import matplotlib.pyplot as plt
import sys

sys.path.append("../..")
from utils.DrawRobot import DrawRobot


def create_room_map():
    # Define the environment
    # A polygon contour is defined as two arrays, specifying the x and y coordinates of each point
    # The polygon is generated by connecting (x_t, y_t) to (x_t+1, y_t+1) with a straight line segment

    # NaN denotes the end of each polygon
    walls = np.array([[2, 12, 12, 10, 10, 9.5, 9.5, 2, 2, 1, 13, 13, 1, 1, np.nan],
                        [2, 2, 10, 10, 8, 8, 10, 10, 2, 1, 1, 11, 11, 1, np.nan]])

    kitchen = np.array([[2, 8.5, 8.5, 9.5, 9.5, 2, 2, np.nan],
                        [9, 9, 8, 8, 10, 10, 9, np.nan]])

    sofa = np.array([[3.5, 7, 7, 3.5, 3.5, np.nan],
                        [6, 6, 7, 7, 6, np.nan]])

    tv_cabinet = np.array([[2.5, 7.5, 7.5, 2.5, 2.5, np.nan],
                            [2, 2, 3, 3, 2, np.nan]])

    table = np.array([[9.5, 11, 11, 9.5, 9.5, np.nan],
                        [3.5, 3.5, 6, 6, 3.5, np.nan]])


    virtual_map = np.concatenate([walls, kitchen, sofa, tv_cabinet, table], axis=1)
    return virtual_map

def express_as_global_point_cloud(z, pose):
    # calculate the cartesian coordinates of the observed point in world space
    x = pose[0] + z[0,:] * np.cos(z[1,:] + pose[2])
    y = pose[1] + z[0,:] * np.sin(z[1,:] + pose[2])

    return np.vstack([x, y])

def express_as_local_point_cloud(z):
    # calculate the cartesian coordinates of the observed point in local space
    x = z[0,:] * np.cos(z[1,:])
    y = z[0,:] * np.sin(z[1,:])

    return np.vstack([x, y])

def plot_observations(z, pose, ax, draw_lines = True, point_color = 'r'):
    """Draw a sensor observation taken from a given pose on a figure.

    Keyword arguments:
    z -- Laser observation
    pose -- Pose from which the observation was taken
    ax -- Figure to plot in
    """

    point_cloud = express_as_global_point_cloud(z, pose)
    for i in range (point_cloud.shape[1]):
        x = np.array(point_cloud[0, i]).reshape(-1)
        y = np.array(point_cloud[1, i]).reshape(-1)

        if draw_lines:
            ax.plot([x, pose[0]], [y, pose[1]], 'g--', linewidth=1)
        ax.plot(x, y, 'o', markersize=4, color=point_color)


def run_laser_and_plot(laser, virtual_map, pose, fig, ax, draw_lines = True, color='r'):
    laser.set_pose(pose)

    # take the measurement
    measurement = laser.take_observation(virtual_map)

    # Plot!
    DrawRobot(fig, ax, pose, axis_percent=0.015, color=color, linewidth=1.5);
    plot_observations(measurement, pose, ax, draw_lines, color)
    return ax

def plot_virtual_map(virtual_map, dimensions_only = False):
    """
    Plots the robot pose, virtual map, beam endpoints, and optionally grid cells to be updated.
    
    Parameters:
    - virtual_map: environment representation using lines.
    """
    
    fig, ax = plt.subplots(figsize=(10, 8))
    
    # Plot the virtual map (environment boundaries or walls)
    if not dimensions_only:
        plt.plot(virtual_map[0, :], virtual_map[1, :], 'k-')    
    
    # Set grid and axis limits
    plt.grid()
    plt.xlim([np.nanmin(virtual_map[0])-2,np.nanmax(virtual_map[0])+2]) # nanmin ignores nan numbers
    plt.ylim([np.nanmin(virtual_map[1])-2,np.nanmax(virtual_map[1])+2])  
    
    # Title and axis labels
    plt.title('Living-room Map')
    plt.xlabel('X position (m)')
    plt.ylabel('Y position (m)')

    return fig, ax
